
.. _program_listing_file_src_hal.c:

Program Listing for File hal.c
==============================

|exhale_lsh| :ref:`Return to documentation for file <file_src_hal.c>` (``src/hal.c``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * PickPlaz ESP32-C3 Port
    * Copyright (c) 2026 Asterion Daedalus https://github.com/Bazmundi
    * SPDX-License-Identifier: MIT
    *
    * This file is part of PickPlaz ESP32-C3 Port and is licensed under the MIT License.
    * See the LICENSE file in the project root for full license text.
    */
   
   /**
    * @file hal.c
    * @brief Implements the ESP32-C3 hardware abstraction layer.
    *
    * @details
    * Provides GPIO, timers, PWM, UART, SPI, I2C, ADC, and optional self-test
    * services using ESP-IDF drivers. The HAL hides platform specifics from the
    * application layer.
    *
    * Thread-safety:
    * - Not thread-safe; callers should serialize access when sharing resources.
    */
   
   #include "hal.h"
   
   #include "hal_config.h"
   
   #include "esp_err.h"
   #include "esp_log.h"
   #include "esp_timer.h"
   
   #include "driver/gpio.h"
   #include "driver/i2c.h"
   #include "driver/ledc.h"
   #include "driver/spi_master.h"
   #include "driver/uart.h"
   #include "esp_adc/adc_oneshot.h"
   
   #include "freertos/FreeRTOS.h"
   #include "freertos/task.h"
   
   static const char *TAG = "hal";
   
   static bool hal_gpio_valid(int pin) {
       return (pin >= 0) && GPIO_IS_VALID_GPIO((gpio_num_t)pin);
   }
   
   static bool hal_gpio_output_valid(int pin) {
       return (pin >= 0) && GPIO_IS_VALID_OUTPUT_GPIO((gpio_num_t)pin);
   }
   
   /**
    * @brief Initializes HAL services.
    *
    * @details
    * Performs lightweight HAL startup and logs the initialization banner.
    *
    * Postconditions:
    * - HAL services are available to callers.
    *
    * Side effects:
    * - Writes a log message.
    *
    * @return HAL_OK on success.
    */
   hal_status_t hal_init(void) {
       ESP_LOGI(TAG, "HAL init (Stage 3)");
       return HAL_OK;
   }
   
   /**
    * @brief Delays execution for the requested number of milliseconds.
    *
    * @details
    * Uses the FreeRTOS tick delay to suspend the calling task.
    *
    * Preconditions:
    * - Must be called from a task context (not an ISR).
    *
    * Side effects:
    * - Suspends the current task.
    *
    * @param ms Delay duration in milliseconds. Zero performs no delay.
    */
   void hal_delay_ms(uint32_t ms) {
       if (ms == 0) {
           return;
       }
       vTaskDelay(pdMS_TO_TICKS(ms));
   }
   
   /**
    * @brief Configures a GPIO pin as a push-pull output.
    *
    * @details
    * Sets the pin to output mode with no pull resistors and applies the initial
    * logic level.
    *
    * Preconditions:
    * - pin must be a valid output-capable GPIO.
    *
    * Postconditions:
    * - GPIO is configured for output and driven to initial_level.
    *
    * Side effects:
    * - Updates GPIO hardware configuration.
    *
    * @param pin GPIO number to configure.
    * @param initial_level Initial logic level to drive.
    * @return HAL_OK on success, HAL_ERR_INVALID on invalid pin/config failure.
    */
   hal_status_t hal_gpio_config_output(int pin, hal_gpio_level_t initial_level) {
       if (!hal_gpio_output_valid(pin)) {
           return HAL_ERR_INVALID;
       }
   
       gpio_config_t cfg = {
           .pin_bit_mask = 1ULL << pin,
           .mode = GPIO_MODE_OUTPUT,
           .pull_up_en = GPIO_PULLUP_DISABLE,
           .pull_down_en = GPIO_PULLDOWN_DISABLE,
           .intr_type = GPIO_INTR_DISABLE,
       };
       if (gpio_config(&cfg) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
       gpio_set_level((gpio_num_t)pin, (int)initial_level);
       return HAL_OK;
   }
   
   /**
    * @brief Configures a GPIO pin as an input with pull settings.
    *
    * @details
    * Sets the pin to input mode and enables the requested pull-up or pull-down.
    *
    * Preconditions:
    * - pin must be a valid GPIO.
    *
    * Postconditions:
    * - GPIO is configured for input with the requested pull configuration.
    *
    * Side effects:
    * - Updates GPIO hardware configuration.
    *
    * @param pin GPIO number to configure.
    * @param pull Pull mode (none/up/down).
    * @return HAL_OK on success, HAL_ERR_INVALID on invalid pin/config failure.
    */
   hal_status_t hal_gpio_config_input(int pin, hal_gpio_pull_t pull) {
       if (!hal_gpio_valid(pin)) {
           return HAL_ERR_INVALID;
       }
   
       gpio_config_t cfg = {
           .pin_bit_mask = 1ULL << pin,
           .mode = GPIO_MODE_INPUT,
           .pull_up_en = (pull == HAL_GPIO_PULL_UP) ? GPIO_PULLUP_ENABLE : GPIO_PULLUP_DISABLE,
           .pull_down_en = (pull == HAL_GPIO_PULL_DOWN) ? GPIO_PULLDOWN_ENABLE : GPIO_PULLDOWN_DISABLE,
           .intr_type = GPIO_INTR_DISABLE,
       };
       if (gpio_config(&cfg) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
       return HAL_OK;
   }
   
   /**
    * @brief Writes a logic level to a GPIO output.
    *
    * Preconditions:
    * - pin must be configured as an output-capable GPIO.
    *
    * Side effects:
    * - Updates the GPIO output level.
    *
    * @param pin GPIO number to write.
    * @param level Logic level to drive.
    * @return HAL_OK on success, HAL_ERR_INVALID on invalid pin.
    */
   hal_status_t hal_gpio_write(int pin, hal_gpio_level_t level) {
       if (!hal_gpio_output_valid(pin)) {
           return HAL_ERR_INVALID;
       }
       gpio_set_level((gpio_num_t)pin, (int)level);
       return HAL_OK;
   }
   
   /**
    * @brief Reads the current logic level of a GPIO.
    *
    * @details
    * Returns HAL_GPIO_LOW if the pin is invalid.
    *
    * @param pin GPIO number to read.
    * @return HAL_GPIO_HIGH or HAL_GPIO_LOW based on the sampled level.
    */
   hal_gpio_level_t hal_gpio_read(int pin) {
       if (!hal_gpio_valid(pin)) {
           return HAL_GPIO_LOW;
       }
       return (hal_gpio_level_t)gpio_get_level((gpio_num_t)pin);
   }
   
   /**
    * @brief Defines the maximum number of HAL timer slots.
    *
    * @details
    * Limits the number of concurrent periodic timers that can be registered via
    * hal_timer_start().
    */
   #define HAL_TIMER_MAX 4
   
   typedef struct {
       esp_timer_handle_t handle;
       hal_timer_callback_t callback;
       void *user_data;
   } hal_timer_entry_t;
   
   static hal_timer_entry_t hal_timers[HAL_TIMER_MAX];
   
   static void hal_timer_dispatch(void *arg) {
       hal_timer_entry_t *entry = (hal_timer_entry_t *)arg;
       if (entry->callback) {
           entry->callback(entry->user_data);
       }
   }
   
   /**
    * @brief Starts a periodic HAL timer.
    *
    * @details
    * Allocates or reuses a timer slot and calls the provided callback at the
    * specified period.
    *
    * Preconditions:
    * - timer_id must be in range [0, HAL_TIMER_MAX).
    * - callback must be non-null.
    * - period_ms must be > 0.
    *
    * Postconditions:
    * - The timer slot is active and invokes callback periodically.
    *
    * Side effects:
    * - Allocates an ESP timer and schedules periodic callbacks.
    *
    * @param timer_id Timer slot identifier.
    * @param period_ms Period in milliseconds.
    * @param callback Function to invoke each period. Must not be NULL.
    * @param user_data Opaque pointer passed to callback.
    * @return HAL_OK on success, HAL_ERR_INVALID on invalid parameters or failure.
    */
   hal_status_t hal_timer_start(int timer_id, uint32_t period_ms,
                                hal_timer_callback_t callback, void *user_data) {
       if (timer_id < 0 || timer_id >= HAL_TIMER_MAX || callback == NULL || period_ms == 0) {
           return HAL_ERR_INVALID;
       }
   
       hal_timer_entry_t *entry = &hal_timers[timer_id];
       if (entry->handle) {
           esp_timer_stop(entry->handle);
           esp_timer_delete(entry->handle);
           entry->handle = NULL;
       }
   
       esp_timer_create_args_t args = {
           .callback = &hal_timer_dispatch,
           .arg = entry,
           .name = "hal_timer"
       };
       if (esp_timer_create(&args, &entry->handle) != ESP_OK) {
           entry->handle = NULL;
           return HAL_ERR_INVALID;
       }
   
       entry->callback = callback;
       entry->user_data = user_data;
   
       uint64_t period_us = (uint64_t)period_ms * 1000ULL;
       if (esp_timer_start_periodic(entry->handle, period_us) != ESP_OK) {
           esp_timer_delete(entry->handle);
           entry->handle = NULL;
           return HAL_ERR_INVALID;
       }
   
       return HAL_OK;
   }
   
   /**
    * @brief Stops a periodic HAL timer.
    *
    * @details
    * Cancels and deletes the timer slot if it is active.
    *
    * Preconditions:
    * - timer_id must be in range [0, HAL_TIMER_MAX).
    *
    * Postconditions:
    * - The timer slot is inactive.
    *
    * Side effects:
    * - Deletes the underlying ESP timer if present.
    *
    * @param timer_id Timer slot identifier.
    * @return HAL_OK on success, HAL_ERR_INVALID on invalid timer_id.
    */
   hal_status_t hal_timer_stop(int timer_id) {
       if (timer_id < 0 || timer_id >= HAL_TIMER_MAX) {
           return HAL_ERR_INVALID;
       }
   
       hal_timer_entry_t *entry = &hal_timers[timer_id];
       if (!entry->handle) {
           return HAL_OK;
       }
   
       esp_timer_stop(entry->handle);
       esp_timer_delete(entry->handle);
       entry->handle = NULL;
       entry->callback = NULL;
       entry->user_data = NULL;
       return HAL_OK;
   }
   
   static esp_timer_handle_t hal_tick_timer;
   static hal_timer_callback_t hal_tick_callback;
   static void *hal_tick_user_data;
   
   static void hal_tick_dispatch(void *arg) {
       (void)arg;
       if (hal_tick_callback) {
           hal_tick_callback(hal_tick_user_data);
       }
   }
   
   /**
    * @brief Starts the global HAL tick timer.
    *
    * @details
    * Configures a periodic ESP timer that calls the provided callback at the
    * requested frequency.
    *
    * Preconditions:
    * - hz must be > 0.
    * - callback must be non-null.
    *
    * Postconditions:
    * - The tick callback is invoked at approximately hz.
    *
    * Side effects:
    * - Allocates and starts an ESP timer.
    *
    * @param hz Tick frequency in Hertz.
    * @param callback Function to invoke on each tick. Must not be NULL.
    * @param user_data Opaque pointer passed to callback.
    * @return HAL_OK on success, HAL_ERR_INVALID on invalid params or failure.
    */
   hal_status_t hal_tick_start(uint32_t hz, hal_timer_callback_t callback, void *user_data) {
       if (hz == 0 || callback == NULL) {
           return HAL_ERR_INVALID;
       }
   
       if (hal_tick_timer) {
           esp_timer_stop(hal_tick_timer);
           esp_timer_delete(hal_tick_timer);
           hal_tick_timer = NULL;
       }
   
       uint64_t period_us = 1000000ULL / hz;
       if (period_us == 0) {
           return HAL_ERR_INVALID;
       }
   
       esp_timer_create_args_t args = {
           .callback = &hal_tick_dispatch,
           .arg = NULL,
           .name = "hal_tick"
       };
       if (esp_timer_create(&args, &hal_tick_timer) != ESP_OK) {
           hal_tick_timer = NULL;
           return HAL_ERR_INVALID;
       }
   
       hal_tick_callback = callback;
       hal_tick_user_data = user_data;
   
       if (esp_timer_start_periodic(hal_tick_timer, period_us) != ESP_OK) {
           esp_timer_delete(hal_tick_timer);
           hal_tick_timer = NULL;
           return HAL_ERR_INVALID;
       }
   
       return HAL_OK;
   }
   
   /**
    * @brief Stops the global HAL tick timer.
    *
    * @details
    * Cancels and deletes the tick timer if it is active.
    *
    * Postconditions:
    * - The global tick timer is inactive.
    *
    * Side effects:
    * - Deletes the underlying ESP timer.
    *
    * @return HAL_OK on success.
    */
   hal_status_t hal_tick_stop(void) {
       if (!hal_tick_timer) {
           return HAL_OK;
       }
       esp_timer_stop(hal_tick_timer);
       esp_timer_delete(hal_tick_timer);
       hal_tick_timer = NULL;
       hal_tick_callback = NULL;
       hal_tick_user_data = NULL;
       return HAL_OK;
   }
   
   static ledc_timer_t hal_pwm_select_timer(int pin) {
       if (pin == BOARD_GPIO_MOTOR_IN1 || pin == BOARD_GPIO_MOTOR_IN2) {
           return LEDC_TIMER_1;
       }
       return LEDC_TIMER_0;
   }
   
   static ledc_timer_bit_t hal_pwm_bits_to_ledc(uint32_t bits) {
       if (bits < 1) {
           bits = 1;
       }
       if (bits >= LEDC_TIMER_BIT_MAX) {
           bits = LEDC_TIMER_BIT_MAX - 1;
       }
       return (ledc_timer_bit_t)bits;
   }
   
   typedef struct {
       bool configured;
       int pin;
       ledc_timer_t timer;
       uint32_t duty_max;
   } hal_pwm_channel_t;
   
   static hal_pwm_channel_t hal_pwm_channels[LEDC_CHANNEL_MAX];
   static bool hal_pwm_timer_configured[LEDC_TIMER_MAX];
   static uint32_t hal_pwm_timer_freq[LEDC_TIMER_MAX];
   static uint32_t hal_pwm_timer_bits[LEDC_TIMER_MAX];
   
   /**
    * @brief Initializes a PWM channel for a GPIO pin.
    *
    * @details
    * Configures the LEDC timer and channel for the requested frequency and
    * resolution. Motor pins are placed on a separate LEDC timer to preserve
    * frequency settings.
    *
    * Preconditions:
    * - channel must be in [0, LEDC_CHANNEL_MAX).
    * - pin must be a valid output-capable GPIO.
    *
    * Postconditions:
    * - The PWM channel is configured and ready for duty updates.
    *
    * Side effects:
    * - Allocates/updates LEDC timer and channel configuration.
    *
    * @param channel LEDC channel index.
    * @param pin GPIO number to drive with PWM.
    * @param freq_hz PWM frequency in Hertz.
    * @param duty_resolution_bits Duty resolution in bits.
    * @return HAL_OK on success, HAL_ERR_INVALID on invalid params or failure.
    */
   hal_status_t hal_pwm_init(int channel, int pin, uint32_t freq_hz,
                             uint32_t duty_resolution_bits) {
       if (channel < 0 || channel >= LEDC_CHANNEL_MAX) {
           return HAL_ERR_INVALID;
       }
       if (!hal_gpio_output_valid(pin)) {
           return HAL_ERR_INVALID;
       }
   
       ledc_timer_t timer = hal_pwm_select_timer(pin);
       ledc_timer_bit_t res = hal_pwm_bits_to_ledc(duty_resolution_bits);
   
       if (!hal_pwm_timer_configured[timer] ||
           hal_pwm_timer_freq[timer] != freq_hz ||
           hal_pwm_timer_bits[timer] != duty_resolution_bits) {
           ledc_timer_config_t timer_cfg = {
               .speed_mode = LEDC_LOW_SPEED_MODE,
               .timer_num = timer,
               .duty_resolution = res,
               .freq_hz = freq_hz,
               .clk_cfg = LEDC_AUTO_CLK,
           };
           if (ledc_timer_config(&timer_cfg) != ESP_OK) {
               return HAL_ERR_INVALID;
           }
           hal_pwm_timer_configured[timer] = true;
           hal_pwm_timer_freq[timer] = freq_hz;
           hal_pwm_timer_bits[timer] = duty_resolution_bits;
       }
   
       ledc_channel_config_t channel_cfg = {
           .gpio_num = pin,
           .speed_mode = LEDC_LOW_SPEED_MODE,
           .channel = (ledc_channel_t)channel,
           .timer_sel = timer,
           .duty = 0,
           .hpoint = 0,
       };
       if (ledc_channel_config(&channel_cfg) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
   
       hal_pwm_channels[channel].configured = true;
       hal_pwm_channels[channel].pin = pin;
       hal_pwm_channels[channel].timer = timer;
       if (duty_resolution_bits >= 31) {
           hal_pwm_channels[channel].duty_max = 0xFFFFFFFFU;
       } else {
           hal_pwm_channels[channel].duty_max = (1U << duty_resolution_bits) - 1U;
       }
   
       return HAL_OK;
   }
   
   /**
    * @brief Updates the PWM duty for a configured channel.
    *
    * @details
    * Clamps duty to the configured maximum for the channel before updating.
    *
    * Preconditions:
    * - channel must be configured via hal_pwm_init().
    *
    * Side effects:
    * - Updates LEDC duty and commits it to hardware.
    *
    * @param channel LEDC channel index.
    * @param duty Duty value in channel resolution units.
    * @return HAL_OK on success, HAL_ERR_INVALID on invalid params or failure,
    *         HAL_ERR_UNSUPPORTED if the channel is not configured.
    */
   hal_status_t hal_pwm_set_duty(int channel, uint32_t duty) {
       if (channel < 0 || channel >= LEDC_CHANNEL_MAX) {
           return HAL_ERR_INVALID;
       }
       if (!hal_pwm_channels[channel].configured) {
           return HAL_ERR_UNSUPPORTED;
       }
   
       uint32_t max_duty = hal_pwm_channels[channel].duty_max;
       if (duty > max_duty) {
           duty = max_duty;
       }
   
       if (ledc_set_duty(LEDC_LOW_SPEED_MODE, (ledc_channel_t)channel, duty) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
       if (ledc_update_duty(LEDC_LOW_SPEED_MODE, (ledc_channel_t)channel) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
       return HAL_OK;
   }
   
   /**
    * @brief Initializes UART0 with the configured pins.
    *
    * @details
    * Only UART0 is supported. Pins are defined in hal_config.h and must be set
    * to non-BOARD_GPIO_UNUSED to enable UART usage.
    *
    * Preconditions:
    * - uart_id must be UART_NUM_0.
    * - UART pins must be configured in hal_config.h.
    *
    * Postconditions:
    * - UART driver is installed and ready for IO.
    *
    * Side effects:
    * - Allocates UART driver resources.
    *
    * @param uart_id UART identifier (must be UART_NUM_0).
    * @param baud_rate Baud rate in bits per second.
    * @return HAL_OK on success, HAL_ERR_UNSUPPORTED on unsupported config,
    *         HAL_ERR_INVALID on invalid parameters or driver failure.
    */
   hal_status_t hal_uart_init(int uart_id, uint32_t baud_rate) {
       if (uart_id != UART_NUM_0) {
           return HAL_ERR_UNSUPPORTED;
       }
   
       if (HAL_UART0_TX_PIN == BOARD_GPIO_UNUSED || HAL_UART0_RX_PIN == BOARD_GPIO_UNUSED) {
           return HAL_ERR_UNSUPPORTED;
       }
   
       if (!hal_gpio_valid(HAL_UART0_TX_PIN) || !hal_gpio_valid(HAL_UART0_RX_PIN)) {
           return HAL_ERR_INVALID;
       }
   
       uart_config_t config = {
           .baud_rate = (int)baud_rate,
           .data_bits = UART_DATA_8_BITS,
           .parity = UART_PARITY_DISABLE,
           .stop_bits = UART_STOP_BITS_1,
           .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
           .source_clk = UART_SCLK_DEFAULT,
       };
   
       if (uart_param_config(uart_id, &config) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
   
       int rts = (HAL_UART0_RTS_PIN == BOARD_GPIO_UNUSED) ? UART_PIN_NO_CHANGE : HAL_UART0_RTS_PIN;
       int cts = (HAL_UART0_CTS_PIN == BOARD_GPIO_UNUSED) ? UART_PIN_NO_CHANGE : HAL_UART0_CTS_PIN;
       if (uart_set_pin(uart_id, HAL_UART0_TX_PIN, HAL_UART0_RX_PIN, rts, cts) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
   
       if (uart_driver_install(uart_id, 256, 0, 0, NULL, 0) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
   
       return HAL_OK;
   }
   
   /**
    * @brief Writes data to UART0.
    *
    * Preconditions:
    * - UART0 has been initialized.
    *
    * Side effects:
    * - Sends bytes over the UART driver.
    *
    * @param uart_id UART identifier (must be UART_NUM_0).
    * @param data Buffer to write. Must not be NULL.
    * @param length Number of bytes to write. Must be > 0.
    * @return Number of bytes written, or HAL_ERR_INVALID on invalid params.
    */
   int hal_uart_write(int uart_id, const uint8_t *data, size_t length) {
       if (uart_id != UART_NUM_0 || data == NULL || length == 0) {
           return HAL_ERR_INVALID;
       }
       return uart_write_bytes(uart_id, data, length);
   }
   
   /**
    * @brief Reads data from UART0.
    *
    * @details
    * Performs a non-blocking read with zero timeout.
    *
    * Preconditions:
    * - UART0 has been initialized.
    *
    * @param uart_id UART identifier (must be UART_NUM_0).
    * @param data Output buffer. Must not be NULL.
    * @param length Maximum number of bytes to read. Must be > 0.
    * @return Number of bytes read, or HAL_ERR_INVALID on invalid params.
    */
   int hal_uart_read(int uart_id, uint8_t *data, size_t length) {
       if (uart_id != UART_NUM_0 || data == NULL || length == 0) {
           return HAL_ERR_INVALID;
       }
       return uart_read_bytes(uart_id, data, length, 0);
   }
   
   static bool hal_i2c_initialized;
   
   /**
    * @brief Initializes the I2C master bus.
    *
    * @details
    * Only I2C_NUM_0 is supported. Pins are defined in hal_config.h.
    *
    * Preconditions:
    * - bus_id must be I2C_NUM_0.
    * - SDA/SCL pins must be configured and valid.
    *
    * Postconditions:
    * - I2C driver is installed and ready for transfers.
    *
    * Side effects:
    * - Allocates I2C driver resources.
    *
    * @param bus_id I2C bus identifier (must be I2C_NUM_0).
    * @param clock_hz Bus clock in Hertz. Zero uses HAL_I2C0_CLOCK_HZ.
    * @return HAL_OK on success, HAL_ERR_UNSUPPORTED on unsupported config,
    *         HAL_ERR_INVALID on invalid parameters or driver failure.
    */
   hal_status_t hal_i2c_init(int bus_id, uint32_t clock_hz) {
       if (bus_id != I2C_NUM_0) {
           return HAL_ERR_UNSUPPORTED;
       }
       if (HAL_I2C0_SDA_PIN == BOARD_GPIO_UNUSED || HAL_I2C0_SCL_PIN == BOARD_GPIO_UNUSED) {
           return HAL_ERR_UNSUPPORTED;
       }
       if (!hal_gpio_valid(HAL_I2C0_SDA_PIN) || !hal_gpio_valid(HAL_I2C0_SCL_PIN)) {
           return HAL_ERR_INVALID;
       }
       if (hal_i2c_initialized) {
           return HAL_OK;
       }
   
       i2c_config_t conf = {
           .mode = I2C_MODE_MASTER,
           .sda_io_num = HAL_I2C0_SDA_PIN,
           .scl_io_num = HAL_I2C0_SCL_PIN,
           .sda_pullup_en = GPIO_PULLUP_ENABLE,
           .scl_pullup_en = GPIO_PULLUP_ENABLE,
           .master.clk_speed = (clock_hz == 0) ? HAL_I2C0_CLOCK_HZ : clock_hz,
       };
   
       if (i2c_param_config(bus_id, &conf) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
       if (i2c_driver_install(bus_id, conf.mode, 0, 0, 0) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
   
       hal_i2c_initialized = true;
       return HAL_OK;
   }
   
   /**
    * @brief Writes data to an I2C device.
    *
    * @details
    * Uses a blocking transfer with a 100 ms timeout.
    *
    * Preconditions:
    * - I2C bus has been initialized.
    *
    * @param bus_id I2C bus identifier (must be I2C_NUM_0).
    * @param addr 7-bit I2C device address.
    * @param data Buffer to write. Must not be NULL.
    * @param length Number of bytes to write. Must be > 0.
    * @return Number of bytes written, or HAL_ERR_INVALID on failure,
    *         HAL_ERR_UNSUPPORTED if the bus is not available.
    */
   int hal_i2c_write(int bus_id, uint8_t addr, const uint8_t *data, size_t length) {
       if (data == NULL || length == 0) {
           return HAL_ERR_INVALID;
       }
       if (hal_i2c_init(bus_id, HAL_I2C0_CLOCK_HZ) != HAL_OK) {
           return HAL_ERR_UNSUPPORTED;
       }
       esp_err_t err = i2c_master_write_to_device(bus_id, addr, data, length,
                                                  pdMS_TO_TICKS(100));
       return (err == ESP_OK) ? (int)length : HAL_ERR_INVALID;
   }
   
   /**
    * @brief Reads data from an I2C device.
    *
    * @details
    * Uses a blocking transfer with a 100 ms timeout.
    *
    * Preconditions:
    * - I2C bus has been initialized.
    *
    * @param bus_id I2C bus identifier (must be I2C_NUM_0).
    * @param addr 7-bit I2C device address.
    * @param data Output buffer. Must not be NULL.
    * @param length Number of bytes to read. Must be > 0.
    * @return Number of bytes read, or HAL_ERR_INVALID on failure,
    *         HAL_ERR_UNSUPPORTED if the bus is not available.
    */
   int hal_i2c_read(int bus_id, uint8_t addr, uint8_t *data, size_t length) {
       if (data == NULL || length == 0) {
           return HAL_ERR_INVALID;
       }
       if (hal_i2c_init(bus_id, HAL_I2C0_CLOCK_HZ) != HAL_OK) {
           return HAL_ERR_UNSUPPORTED;
       }
       esp_err_t err = i2c_master_read_from_device(bus_id, addr, data, length,
                                                   pdMS_TO_TICKS(100));
       return (err == ESP_OK) ? (int)length : HAL_ERR_INVALID;
   }
   
   static bool hal_spi_initialized;
   static spi_device_handle_t hal_spi_device;
   
   #ifdef HAL_SELFTEST
   static void hal_selftest_tick_cb(void *ctx) {
       volatile uint32_t *count = (volatile uint32_t *)ctx;
       (*count)++;
   }
   #endif
   
   /**
    * @brief Initializes the SPI bus and device handle.
    *
    * @details
    * Only bus_id 0 is supported and mapped to SPI2_HOST. Pins are defined in
    * hal_config.h.
    *
    * Preconditions:
    * - SPI pins must be configured and valid.
    *
    * Postconditions:
    * - SPI bus is initialized and device handle is ready.
    *
    * Side effects:
    * - Allocates SPI bus resources.
    *
    * @param bus_id SPI bus identifier (must be 0).
    * @param clock_hz Clock rate in Hertz. Zero uses HAL_SPI0_CLOCK_HZ.
    * @param mode SPI mode (0-3).
    * @return HAL_OK on success, HAL_ERR_UNSUPPORTED on unsupported config,
    *         HAL_ERR_INVALID on invalid parameters or driver failure.
    */
   hal_status_t hal_spi_init(int bus_id, uint32_t clock_hz, uint8_t mode) {
       if (bus_id != 0) {
           return HAL_ERR_UNSUPPORTED;
       }
       if (HAL_SPI0_MOSI_PIN == BOARD_GPIO_UNUSED || HAL_SPI0_MISO_PIN == BOARD_GPIO_UNUSED ||
           HAL_SPI0_SCLK_PIN == BOARD_GPIO_UNUSED) {
           return HAL_ERR_UNSUPPORTED;
       }
       if (!hal_gpio_valid(HAL_SPI0_MOSI_PIN) || !hal_gpio_valid(HAL_SPI0_MISO_PIN) ||
           !hal_gpio_valid(HAL_SPI0_SCLK_PIN)) {
           return HAL_ERR_INVALID;
       }
       if (hal_spi_initialized) {
           return HAL_OK;
       }
   
       spi_bus_config_t buscfg = {
           .mosi_io_num = HAL_SPI0_MOSI_PIN,
           .miso_io_num = HAL_SPI0_MISO_PIN,
           .sclk_io_num = HAL_SPI0_SCLK_PIN,
           .quadwp_io_num = -1,
           .quadhd_io_num = -1,
           .max_transfer_sz = 4096,
       };
   
       if (spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
   
       spi_device_interface_config_t devcfg = {
           .clock_speed_hz = (clock_hz == 0) ? HAL_SPI0_CLOCK_HZ : clock_hz,
           .mode = mode,
           .spics_io_num = (HAL_SPI0_CS_PIN == BOARD_GPIO_UNUSED) ? -1 : HAL_SPI0_CS_PIN,
           .queue_size = 1,
       };
   
       if (spi_bus_add_device(SPI2_HOST, &devcfg, &hal_spi_device) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
   
       hal_spi_initialized = true;
       return HAL_OK;
   }
   
   /**
    * @brief Performs a blocking SPI transfer.
    *
    * @details
    * Sends tx bytes (if provided) and optionally captures rx bytes.
    *
    * Preconditions:
    * - SPI bus has been initialized.
    *
    * @param bus_id SPI bus identifier (must be 0).
    * @param tx Optional transmit buffer (may be NULL).
    * @param rx Optional receive buffer (may be NULL).
    * @param length Number of bytes to transfer. Must be > 0.
    * @return Number of bytes transferred, or HAL_ERR_INVALID on failure,
    *         HAL_ERR_UNSUPPORTED if the bus is not available.
    */
   int hal_spi_transfer(int bus_id, const uint8_t *tx, uint8_t *rx, size_t length) {
       if (length == 0) {
           return HAL_ERR_INVALID;
       }
       if (hal_spi_init(bus_id, HAL_SPI0_CLOCK_HZ, HAL_SPI0_MODE) != HAL_OK) {
           return HAL_ERR_UNSUPPORTED;
       }
   
       spi_transaction_t t = {
           .length = length * 8,
           .tx_buffer = tx,
           .rx_buffer = rx,
       };
   
       esp_err_t err = spi_device_transmit(hal_spi_device, &t);
       return (err == ESP_OK) ? (int)length : HAL_ERR_INVALID;
   }
   
   static adc_oneshot_unit_handle_t hal_adc_handle;
   static bool hal_adc_initialized;
   
   /**
    * @brief Initializes the ADC oneshot unit.
    *
    * @details
    * Uses ADC_UNIT_1 and prepares it for per-channel configuration.
    *
    * Postconditions:
    * - ADC oneshot handle is available.
    *
    * Side effects:
    * - Allocates ADC unit resources.
    *
    * @return HAL_OK on success, HAL_ERR_INVALID on initialization failure.
    */
   hal_status_t hal_adc_init(void) {
       if (hal_adc_initialized) {
           return HAL_OK;
       }
   
       adc_oneshot_unit_init_cfg_t init_cfg = {
           .unit_id = ADC_UNIT_1,
       };
       if (adc_oneshot_new_unit(&init_cfg, &hal_adc_handle) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
   
       hal_adc_initialized = true;
       return HAL_OK;
   }
   
   /**
    * @brief Reads a raw ADC sample from the specified channel.
    *
    * @details
    * Configures channel attenuation and bit width on each read to match the
    * default ESP-IDF oneshot configuration.
    *
    * Preconditions:
    * - channel must be a valid ADC channel for ADC_UNIT_1.
    *
    * @param channel ADC channel number.
    * @return Raw ADC reading on success, HAL_ERR_INVALID on failure,
    *         HAL_ERR_UNSUPPORTED if channel is disabled.
    */
   int hal_adc_read(int channel) {
       if (channel == BOARD_GPIO_UNUSED) {
           return HAL_ERR_UNSUPPORTED;
       }
       if (channel < 0) {
           return HAL_ERR_INVALID;
       }
   
       if (hal_adc_init() != HAL_OK) {
           return HAL_ERR_UNSUPPORTED;
       }
   
       adc_oneshot_chan_cfg_t cfg = {
           .atten = ADC_ATTEN_DB_12,
           .bitwidth = ADC_BITWIDTH_DEFAULT,
       };
       if (adc_oneshot_config_channel(hal_adc_handle, (adc_channel_t)channel, &cfg) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
   
       int raw = 0;
       if (adc_oneshot_read(hal_adc_handle, (adc_channel_t)channel, &raw) != ESP_OK) {
           return HAL_ERR_INVALID;
       }
       return raw;
   }
   
   /**
    * @brief Runs a basic HAL self-test sequence.
    *
    * @details
    * Validates GPIO, tick timer, PWM, and optional peripheral bring-up. Only
    * compiled when HAL_SELFTEST is defined.
    *
    * Side effects:
    * - Reconfigures GPIO/PWM peripherals for test patterns.
    * - Writes test output to the UART when available.
    *
    * @note Intended for development builds only.
    */
   void hal_selftest_run(void) {
   #ifndef HAL_SELFTEST
       return;
   #else
       ESP_LOGI(TAG, "HAL self-test start");
   
       int led_pins[] = {
           BOARD_GPIO_LED0,
           BOARD_GPIO_LED1,
           BOARD_GPIO_LED2,
           BOARD_GPIO_LED3
       };
   
       for (size_t i = 0; i < sizeof(led_pins) / sizeof(led_pins[0]); i++) {
           if (hal_gpio_config_output(led_pins[i], HAL_GPIO_LOW) == HAL_OK) {
               hal_gpio_write(led_pins[i], HAL_GPIO_HIGH);
               hal_delay_ms(200);
               hal_gpio_write(led_pins[i], HAL_GPIO_LOW);
           }
       }
   
       hal_gpio_config_input(BOARD_GPIO_BUTTON_FWD, HAL_GPIO_PULL_UP);
       hal_gpio_config_input(BOARD_GPIO_BUTTON_REV, HAL_GPIO_PULL_UP);
       ESP_LOGI(TAG, "Button FWD=%d REV=%d",
                hal_gpio_read(BOARD_GPIO_BUTTON_FWD),
                hal_gpio_read(BOARD_GPIO_BUTTON_REV));
   
       volatile uint32_t tick_count = 0;
       hal_tick_start(1000, hal_selftest_tick_cb, (void *)&tick_count);
       hal_delay_ms(1100);
       hal_tick_stop();
       ESP_LOGI(TAG, "Tick count (1s): %u", (unsigned)tick_count);
   
       hal_pwm_init(0, BOARD_GPIO_LED0, HAL_PWM_LED_FREQ_HZ, HAL_PWM_DUTY_RES_BITS);
       hal_pwm_set_duty(0, (1U << (HAL_PWM_DUTY_RES_BITS - 1)));
   
       if (hal_uart_init(UART_NUM_0, HAL_UART0_BAUD_DEFAULT) == HAL_OK) {
           const char banner[] = "HAL UART0 ready\n";
           hal_uart_write(UART_NUM_0, (const uint8_t *)banner, sizeof(banner) - 1);
       }
   
       if (HAL_I2C0_SDA_PIN != BOARD_GPIO_UNUSED && HAL_I2C0_SCL_PIN != BOARD_GPIO_UNUSED) {
           hal_i2c_init(I2C_NUM_0, HAL_I2C0_CLOCK_HZ);
       }
   
       if (HAL_SPI0_MOSI_PIN != BOARD_GPIO_UNUSED && HAL_SPI0_SCLK_PIN != BOARD_GPIO_UNUSED) {
           hal_spi_init(0, HAL_SPI0_CLOCK_HZ, HAL_SPI0_MODE);
       }
   
       if (HAL_ADC_DEFAULT_CHANNEL != BOARD_GPIO_UNUSED) {
           int adc_value = hal_adc_read(HAL_ADC_DEFAULT_CHANNEL);
           ESP_LOGI(TAG, "ADC default channel=%d value=%d", HAL_ADC_DEFAULT_CHANNEL, adc_value);
       }
   
       ESP_LOGI(TAG, "HAL self-test complete");
   #endif
   }
